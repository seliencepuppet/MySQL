
数据排序的情况非常的常见，在mysql当中有功能可以对数据如何排序进行相关的操作，首先来做个实验创建一张新的表对其进行相关排序操作

```sql
CREATE TABLE `user_test`(
  `id` bigint(20) not null auto_increment comment '数据编号id',
  `name` varchar(50) not null comment '英雄的名字',
  `date_time` datetime not null comment '英雄的拥有时间',
  `status` int(5) not null comment '目前的状态',
  PRIMARY KEY(`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 comment '英雄表';
```

接下来向该表当中添加相关的测试数据

```sql
insert into user_test (`name`, `date_time`, `status`) values 
('鲁班七号', '2018-03-05 11:09:00', 1),
('庄周', '2018-03-06 11:09:00', 1),
('孙策', '2018-03-07 11:09:00', 1), 
('小乔', '2018-04-08 11:09:00', 2),
('司马懿', '2018-04-17 11:09:00', 1),
('诸葛亮', '2018-04-20 13:09:00', 2),
('赵云', '2018-04-20 01:09:00', 4),
('孙倩倩', '2018-04-28 11:09:00', 2),
('马超', '2018-04-30 11:09:00', 1),
('关羽', '2018-05-08 11:09:00', 4),
('苏烈', '2018-05-07 11:09:00', 3),
('百里守约', '2018-05-18 11:09:00', 3),
('花木兰', '2018-06-07 11:09:00', 4),
('孙尚香', '2018-06-18 11:09:00', 2),
('司马懿', '2018-04-21 11:09:00', 1),
('周公瑾', '2018-04-24 11:09:00', 4),
('李白', '2018-04-20 11:09:00', 5),
('貂蝉', '2018-04-29 11:09:00', 2),
('韩信', '2018-04-19 11:09:00', 3),
('白起', '2018-05-01 11:09:00', 2);
```

其中排序又分为二中排法，一种是升序排列，另外一种是降序排列，凡是数据要排序之前必须要加上 ORDER BY ... DESC|ASC 这些关键字

1) DESC: 代表着数据降序
2) ASC: 代表着数据升序


现在要对这些测试数据按照创建的时间进行排序显示，语句如下

```sql
select * from user_test order by date_time DESC;
```

按照升序排列

```sql
select * from user_test order by date_time ASC;
```

还可以指定用多个字段进行排序

```sql
select * from user_test order by status, date_time DESC;
```

有的时候会遇到这种情况希望数据当中status为4的排在首位，2的排在第二位，3的排在第三位，1的排在第四位，5的排在第五位这个时候mysql也支持数据自定义排序不过要使用一个关键字来进行 FIELD(`status`, 4,2,3,1,5), 示例如下:

为什么后面还要加上 date_time，这个是因为按照status字段划分好排序顺序之后，有多条status结果为一个相同的数字那这样排序就不好进行区分了，所以在后面额外指定了一个可以进行区分的时间字段然后倒序进行排列

```sql
select * from user_test order by FIELD(`status`, 4, 2, 3, 1, 5), date_time DESC;
```
